# 第四章  连接管理

## TCP连接


###TCP的可靠数据通道
HTTP连接实际上就是TCP连接和一些使用连接的规则。TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确地传输出来。

### TCP流是分段的、由IP分组传送


### 保持TCP连接的正确运行

在任意时刻计算机都可以有几条TCP连接处于打开状态。TCP是通过端口号来保持所有这些连接的正确运行。

IP地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。TCP连接是通过4个值来识别的：
	
	<源IP地址、源端口号、目的IP地址、目的端口号>

这四个值一起唯一的定义了一条连接。两条不同的TCP连接不能拥有4个完全想听的地址组件值(但不同连接的部分组件可以拥有相同的值)。

###用TCP套接字编程

套接字(源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。)

操作系统提供了了一些操纵其TCP连接的工具。这个套接字API向HTTP程序员隐藏了TCP和IP的艘油细节。

套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。

## 对TCP性能的考虑

### HTTP事物的时延
![串行HTTP事务的时间线](https://i.imgur.com/ETxCwDt.png)

与建立TCP连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的，除非客户端或服务器超载，或正在处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的。


HTTP事务的时延有一下几种主要原因。

* 客户端受限需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。

* 接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器会送一个请求接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会快速的叠加起来。

* 一旦连接建立起来，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。

* 然后，Web服务器会回送HTTP响应，这也需要花费时间。


### TCP连接的握手时延

小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。

### 延迟确认

由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP实现了自己的确认机制来确保数据的成功传输。

每个TCP端都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。

由于确认报文很小，所以TCP允许在发送相同方向的输出数据分组中对其进行“捎带”。为了增加确认报文找到桐乡传输数据分组的可能性，很多TCP栈都实现了一种“延迟确定”算法。

延迟确定算法会在一个特定的窗口时间（通常是100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。

但是HTTP具有双峰特征的请求-应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，便便没有那么多。通常，延迟确认算法会引入相当的的时延。

在对TCP栈的任何参数进行修改之前，一定要对自己在做什么有清醒的认识。对TCP配置进行的任意修改，都要绝对确保应用程序不会引发这些算法所要避免的问题。

### TCP慢启动

TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。

TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。如果某个HTTP事务有大连数据要发送，必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为“打开拥塞窗口”。

### Nagle算法与TCP_NODELAY

TCP有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入TCP栈中。但是每个TCP段中至少装载了40个字符的标记和首部，所以如果TCP发送了大量包含少量数据的分组，网络的性能就会严重下降。

Nagle算法试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。

Nagle算法鼓励发送全尺寸的段。如果其他分组让在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中累计了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出来。

Nagle算法会引发集中HTTP性能问题。受限小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的扼腕数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题——Nagle算法会组织数据的发送，知道有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100~200毫秒。

HTTP应用程序常常会在自己的占中设置参数TCP_NODELAY，禁用Nagle算法提高性能。如果这么做的话，一定要确保会向TCP写入大块的数据，这样就不会产生一对小分组了。

### TIME_WAIT累计与端口耗尽

当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来纪律最近所关闭连接的IP地址和端口号。这类信息值会维持一小段时间，通常是所估计的最大分段使用期的两倍(称为2MSL，通常为2分钟)左右。这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。

## HTTP连接的处理

### 常被误解的Connection首部

HTTP的Connection首部字段中有一个逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中取得选项。

Connection首部可以承载3种不同类型的标签，

* HTTP首部字段名，列出了只与此连接有关的首部；
* 任意标签值，用于描述此连接的非标准选项；
* 值close，说明操作完成之后需要关闭这条持久连接。

如果连接标签中包含了一个HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。再将报文转发出去之前，必须删除Connection首部列出的所有首部字段。

而且，可能还会有少量没有作为Connection首部值列出，但一定不能被代理转发的逐跳首部。其中包括Proxy-Authenticate、Proxy-Connection、Transfer-Encoding和Upgrade。

### 串行事务处理时延

如果只对连接进行简单的管理，TCP的性能时延可能会叠加起来。假设有一个包含了3个嵌入图片的Web页面。浏览器需要发起4个HTTP事务来显示此页面。如果每个事务都需要一条新的连接，那么连接时延和慢启动时延会叠加起来。

串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，所以在家在了足够多的对象之前，无法再屏幕上显示任何内容。

## 并行连接

### 并行连接可能会提高页面的加载速度

包含嵌入对象的组合页面如果客服单桥连接的空载时间和带宽限制，加载速度也会有所提高。

### 并行连接不一定更快

客户端的网络带宽不足时，大部分时间可能都是用来传送数据的。如果并行在家多个对象，每个随想都回去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。

而且，打开大量连接会消耗很多内存资源，从而引发自身的性能问题。客户端可能可以打开数百个连接，一百个用户同时发出申请，每个用户打开100个连接，服务器就要负责处理10000个连接。这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。

实际上，浏览器确实使用了并行连接，但它们将并行连接的总数限制为一个较小的值（通常为4个）。服务器可以随意关闭来自特定客户端的超量连接。

## 持久连接

Web客户端经常会打开到同一个站点的连接。这种形式被称为站点本地性(site locality)。

因此，HTTP1.1允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。

在事务处理结束之后仍然保持在打开状态的TCP连接被称为持久连接。持久连接会在不同事务之间保持打开状态，知道客户端或服务器决定将其关闭为止。

重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。

### 持久以及并行连接

现在，很多Web应用程序都会打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型：比较老的HTTP/1.0+“keep-alive”连接，以及现代的HTTP/1.1“persistent”连接。

### HTTP/1.0+“keep-alive”连接

与串行连接相比，keep-alive连接由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。

### keep-alive操作

可以通过包含Connection：Keep-Alive首部请求将一条连接保持在打开状态。

如果服务器原以为吓一跳请求将连接保持打开状态，就在响应中包含相同的首部。如果响应中没有Connection：Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。

### Keep-Alive选项

可以用keep-alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的行为

* 参数timeout是在keep-alive响应首部发送的。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。


* 参数max是在keep-alive响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。


* Keep-Alive首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为name [=value]。

### Keep-Alive简介的限制和规则

* 在HTTP/1.0中，keep-alive并不是默认使用的。客户端必须发送一个Connection：Keep-Alive请求首部来激活keep-alive连接。

* Connection：Keep-Alive首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送Connection：Keep-Alive首部，服务器就会在那条请求之后关闭连接。


* 客户端探明响应中没有Connection：Keep-Alive响应首部，就可以知道服务器发出相应之后是否会关闭连接了。


* 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的请求下，才能将连接保持在打开状态——也就是说实体的主体部分必须有正确的Content-Length，有多不见媒体类型，或者用分段传输编码的方式进行了编码。


* 代理和网关必须执行Connection首部的规则。


* 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的相应之前连接就关闭了，客户端就一定要做好重试请求的准备。

### Keep-Alive和哑代理

哑代理：不识别Connection首部的代理。

假设有一个Web客户端正通过一个座位盲中继使用的哑代理与Web服务器进行对话。

1. Web客户端想代理发送了一条报文，其中包含了connection:Keep-Alive首部，如果可能的话请求建立一条keep-alive连接。客户端等待响应，已确定对方是否认可它对keep-alive信道的请求。
2. 哑代理收到了这条HTTP请求，但它并不理解Connection首部。代理不知道keep-alive是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器。但Connection首部是个逐跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输。
3. 经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection：Keep-Alive首部时，会误以为代理(对不武器来说，这个代理看起来就和艘油其他客户端一样)希望进行keep-alive对话！Web服务器同意进行keep-alive对话，并回送了一个Connection：Keep-Alive响应首部。所以，此时Web服务器认为它在与代理进行keep-alive对话，会遵循keep-alive的规则。但代理却对keep-alive一无所知。
4. 哑代理将Web服务器的响应报文会送诶客户端，并将来自Web服务器的Connection：Keep-Alive首部一起传送过去。客户端看到这个首部，就会认为代理同意进行keep-alive对话。
5. 由于代理对keep-alive一无所知，所以会将收到的所有数据都会送给客户端，然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将链接保持在打开状态了，所以不会关闭连接。这样代理就会挂在那里等待连接的关闭。
6. 客户端收到了会送的响应报文时，会立即转向下一条请求，在keep-alive连接上向代理发送另一条请求。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。
7. 这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并将其关闭为止。


### 插入Proxy-Connection

Netscape的浏览器及代理实现者们提出了一个对盲中继问题的变通做法，这种做法引入了一个名为Proxy-Connection的新首部，解决了在客户端后面紧跟着一个盲中继搜带来的问题。

浏览器会向代理发送非标准的Proxy-Connection扩展首部。如果代理是盲中继，它会将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部。但如果代理能够理解持久连接的握手动作，就用一个Connection首部取代无异议的Proxy-Connection首部，然后将其发送给服务器，已收到预期的效果。

在客户端和服务器之间只有一个代理时可以用这种方案来解决问题。而且，网络中出现“不可见”代理的情况现在变得很常见了，这些代理可以是防火墙，拦截缓存，或者是反向代理服务器的加速器。这些设备对浏览器是不可见的，所以浏览器不会向他们发送Proxy-Connection首部。

### HTTP/1.1持久连接

HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接的改进型设计取代了它。

HTTP/1.1持久连接在默认情况下是激活的。除非特别指明，否则HTTP/1.1假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显示地添加一个Connection：close首部。

客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection：close并不意味着服务器城虐永远将连接保持在打开状态。

### 持久连接的限制和规则

* 发送了Connection：close请求首部之后，客户端就无法在发条连接上发送更多的请求了。
* 如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection：close请求首部。
* 只有当连接上所有的报文都有正确的、自定义报文长度时——也就是实体主体部分的长度都和相应的Content-Length一致，或者是用分块传输编码方式编码——连接才能持久保持。
* HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接——每个持久连接都只适用于一条传输。
* HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接，除非它们了解客户端的处理能力。实际上这一点是很难做到的，很多厂商都违背了这一原则。
* HTTP/1.1设备都可以在任意时刻关闭连接。
* HTTP/1.1应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累计起来的副作用，客户端都应该重试这条请求。
* 一个用户端对任何服务器或代理最多只能维护两条持久连接，以防止服务器过载。

## 管道化连接

HTTP/1.1允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。

对管道化连接有几条限制。

* 如果HTTP客户端无法确认连接是持久的，就不应该使用管道。
* 必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了就没办法将其与请求匹配起来。
* HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发艘油未完成的管道化请求。
* HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。


## 关闭连接的奥秘

### "任意"解除连接

所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。

但是，服务器永远无法确定在它关闭"空闲"连接的那一刻，在线路那一头的客户端有没有数据发送。

### Content-Length及结尾操作

每条HTTP响应都应该有精确的Content-Length首部，用以描述相应主体的尺寸。如果没有，或者包含错误的长度指示，这样就要以来服务器发出的连接关闭来说明数据的真实末尾。

客户端或代理收到一条随连接管壁而结束的HTTP相应将，且实际传输的实体长度与Content-Length并不匹配时，接收端就应该质疑长度的正确性。


###连接关闭容限、重试以及幂等性

即时在非错误情况下，连接可以在任意时刻关闭。HTTP应用程序要做好正确的护理非预期关闭的准备。如果在客户端执行事物的过程中，传输连接关闭了，那么除非事务处理会带来一些副作用，否则客户端就应该重新打开连接，并重新试一次。

如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是幂等的。实现者们可以认为GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法就是共享这一特性。客户端不应该以管道化方式传送非幂等请求。要发送一条非幂等请求，就需要等待来自前一条请求的响应状态。

### 正常关闭连接

TCP连接是双向的。TCP连接的每一端都有一个输入队列和一个输入队列，用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。

> 完全关闭与半关闭
>>
>应用程序可以关闭TCP输入和输出信道中的任意一个，或者将两个都关闭了。套接字调用close()会将TCP连接的输入和输出信道都关闭了。这被称作"完全关闭"。还可以用套接字调用shutdown()单独关闭输入或输出信道。这被称为"半关闭"。

>TCP关闭及重置错误
>>
>当应用程序开始于很多其他类型的HTTP客户端、服务器和代理进行对话且开始使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误就变得很重要了。
>>
>总之，关闭连接的输出信道总是很安全的。
>>
>关闭连接的输入信道比较危险。
>>
>如果另一端向你已关闭的输入信道发送数据，操作系统就会想另一端的机器回送一条TCP"连接被对端重置"的报文。大部分操作系统都会将这种情况作为很严重的错误来处理，删除对端还未读取的艘油缓存数据。

>正常关闭
>>
>HTTP规范建议，当客户端或服务器突然要关闭一条连接时，应该“正常的关闭传输连接”，但它并没有说明应该如何去做。
>>
>实现正常关闭的应用程序受限应该关闭它们的输出信道，然后等待连接另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据之后，连接就会被完全关闭，而不会有重置的危险。
>>
>想要关闭连接的应用程序应该向半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间内对端没有关闭输入信道，用用程序可以强制关闭连接，以节省资源。















