# 第七章 缓存

## 7.1 冗余的数据传输

有很多客户端访问了一个修行的原始服务器页面时，服务器会多次传送同一份文档，每次传送给一个客户端。一些相同的字节会在网络综一遍遍地传输。有了缓存，就可以保留第一条服务器相应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的、被浪费掉了的重复流量。

## 7.2 带宽瓶颈

缓存还可以缓解网络的瓶颈问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能——尤其是要传输比较的的文件时。

## 7.3 瞬间拥塞

缓存在破幻瞬间拥塞(Flash Crowds)时显得非常重要。突发事件使很多人几乎同时去访问一个Web文档时，就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃。

## 7.4 距离时延

即使带宽不是问题，吉利也可能成为问题。没人爱网络路哟器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著地时延。


将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。

## 7.5 命中和未命中的

缓存无法保存世界上每份文档的副本。

可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中。其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存未命中。

### 7.5.1 再验证

原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看他们保存的副本是否仍是服务器上最新的副本。这些“新鲜度监测”被称为HTTP再验证。为了有效地进行再验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。

缓存可以在任意时刻，以任意的频率对副本进行再验证。但大部分缓存只有在客户端发起请求，且副本旧的足以需要检测的时候，才会对副本进行再验证。

缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。只要缓存知道副本仍然有效，就会再次将副本标示为暂时新鲜，并将副本提供给客户端，这被称为再验证命中或缓慢命中。这种方式确实要与换是服务器进行核对，所以回避单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中要快一些。

HTTP为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是If-Modified-Since首部。讲这个首部添加到GET请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。


下面列出了在3种情况下服务器收到GET If-Modified-Since请求时会发生的情况：

* 再验证命中<br>如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP 304 Not Modified 响应。

* 再验证未命中<br>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应

* 对象被删除<br>如果服务器对象已经被删除了，服务器就回送一个404 Not Found 响应，缓存也会将其副本删除。


### 7.5.2 命中率

由缓存提供服务的其你去所占的比例称为缓存命中率。缓存的管理者希望缓存命中率接近100%，而实际得到的命中率则与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。缓存的好处是，即使是中等规模的缓存，其所包含的常见文档足以显著地提高性能、减少流量了。缓存会努力确保将有用的内容保存在缓存中。

### 7.5.3 字节命中率

由于文档不全是统一尺寸的，所以文档命中率并不能说明一切。由此而大型对象访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，有些人更愿意使用字节命中率作为度量值。

字节命中率表示得失缓存提供的字节在传输的所有字节中所占的比例。通过这种度量方式，可以得知字节生流浪的程度。

文档命中率和字节命中率对缓存性能的评估都是很有用的。文档命中率说明组织了多少通往外部网络的Web事务。提高文档命中率对降低整体延迟很有好处。字节命中率说明阻止了多少字节传向因特网。提高字节命中率对节省带宽很有利。


### 7.5.4 区分命中和未命中的情况

客户端有一种方法判断响应是否来自缓存，就是使用Date首部。将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存响应。客户端也可以通过Age首部来检测缓存的响应，通过这个首部可以分表这条相应的使用期。

## 7.6 缓存的拓扑结构

### 7.6.1 私有缓存

私有缓存不需要恨得的动力或存储空间，这样就可以将其做的很小，很便宜。Web浏览器中内建的私有缓存——大多数浏览器多会将常用的文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置。
 

### 7.6.2 公有代理缓存

公有缓存是特殊的共享代理服务器，被称为缓存代理服务器(caching proxy server)，代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。


### 7.6.3 代理缓存的层次结构

在实际中，事项层次化的缓存是很有意义的，在这种结构中，在较小缓存命中的请求会被导向较大的父缓存，由它来为剩下的那些“提炼过的”流量提供服务。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能功能更强的缓存来装载更多用户共享的文档。


在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，当代理链路变得很长的情况下，这种性能损耗会变得非常明显。

### 7.6.4 网状缓存、内容路由以及对等缓存

有些网络结构会构建复杂的网状缓存。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的通信决策，决定于哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和送达，因此可将其称为内容路由。

网状缓存中内容路由设计的缓存要完成下列所有功能。

* 根据URL在父缓存与原始服务器之间进行动态的选择。
* 根据URL动态的选择一个特定的父缓存。
* 前往父缓存之前，在本地缓存中搜索已缓存的副本。
* 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过他们的缓存。

缓存之间这些更为复杂的关系允许不同的组织互为对等实体，将它们的缓存连接起来实现共赢。提供可选的对等支持的缓存被称为兄弟缓存。HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP进行了扩展，比如因特网缓存协议(ICP)和超文本缓存协议（HTCP）。

## 7.7 缓存的处理步骤

![](https://i.imgur.com/Hvy1lI1.png)

### 第一步——接收

在第一部中，缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。

### 第二步——解析

接下来，缓存将请求报文解析为片段，将首部的哥哥部分放入易于操作的数据结构中。这样缓存软件更容易处理首部字段并修改它们了。

### 第三步——查找

第三步中，缓存读取了URL，查找本地副本。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取。或者返回一条错误信息。

已缓存对象包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象还包含了一些元数据，用来记录对象在缓存中停留了多长时间，以及他被用过多少次等。

### 第四步———新鲜度检测

HTTP通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档时“新鲜的”，缓存可以在不联系服务器的情况下直接提供该文档。但一旦已缓存副本停留的时间太长了，超过了文档的新鲜度限值，就认为对象过时了，在提供该文档之前，缓存要再次与服务器进行确认，以检查文档是否发生了变化。客户端发送给缓存的所有请求首部紫衫都可以强制进行再验证，或者温泉避免再验证，这使得事情变得更加复杂了。

HTTP有一组非常复杂的新鲜度检测规则，缓存产品支持的大量配置选项，以及与非HTTP新鲜度标准进行互通的需要则使问题变得更加严重了。

###  第五步——创建响应

我们希望缓存的响应看起来就像来自原始服务器的一样，缓存将一缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础手部进行了修改和扩充。

缓存负责对这些首部进行改造，以便与客户端的要求相匹配。注意，缓存不应该调整Date首部。


### 第六步——发送

一旦响应首部准备好了，缓存就响应会送给客户端。代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效的发送数据，通常避免在本地缓存和网络I/O缓冲区之间进行文档内容的复制。

### 第七部——日志

大多数缓存会保存日志文件以及与缓存的适用有关的一些统计数据。






