# 第七章 缓存

## 7.1 冗余的数据传输

有很多客户端访问了一个修行的原始服务器页面时，服务器会多次传送同一份文档，每次传送给一个客户端。一些相同的字节会在网络综一遍遍地传输。有了缓存，就可以保留第一条服务器相应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的、被浪费掉了的重复流量。

## 7.2 带宽瓶颈

缓存还可以缓解网络的瓶颈问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能——尤其是要传输比较的的文件时。

## 7.3 瞬间拥塞

缓存在破幻瞬间拥塞(Flash Crowds)时显得非常重要。突发事件使很多人几乎同时去访问一个Web文档时，就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃。

## 7.4 距离时延

即使带宽不是问题，吉利也可能成为问题。没人爱网络路哟器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著地时延。


将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。

## 7.5 命中和未命中的

缓存无法保存世界上每份文档的副本。

可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中。其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存未命中。

### 7.5.1 再验证

原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看他们保存的副本是否仍是服务器上最新的副本。这些“新鲜度监测”被称为HTTP再验证。为了有效地进行再验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。

缓存可以在任意时刻，以任意的频率对副本进行再验证。但大部分缓存只有在客户端发起请求，且副本旧的足以需要检测的时候，才会对副本进行再验证。

缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。只要缓存知道副本仍然有效，就会再次将副本标示为暂时新鲜，并将副本提供给客户端，这被称为再验证命中或缓慢命中。这种方式确实要与换是服务器进行核对，所以回避单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中要快一些。

HTTP为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是If-Modified-Since首部。讲这个首部添加到GET请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。


下面列出了在3种情况下服务器收到GET If-Modified-Since请求时会发生的情况：

* 再验证命中<br>如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP 304 Not Modified 响应。

* 再验证未命中<br>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应

* 对象被删除<br>如果服务器对象已经被删除了，服务器就回送一个404 Not Found 响应，缓存也会将其副本删除。


### 7.5.2 命中率

由缓存提供服务的其你去所占的比例称为缓存命中率。缓存的管理者希望缓存命中率接近100%，而实际得到的命中率则与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。缓存的好处是，即使是中等规模的缓存，其所包含的常见文档足以显著地提高性能、减少流量了。缓存会努力确保将有用的内容保存在缓存中。

### 7.5.3 字节命中率

由于文档不全是统一尺寸的，所以文档命中率并不能说明一切。由此而大型对象访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，有些人更愿意使用字节命中率作为度量值。

字节命中率表示得失缓存提供的字节在传输的所有字节中所占的比例。通过这种度量方式，可以得知字节生流浪的程度。

文档命中率和字节命中率对缓存性能的评估都是很有用的。文档命中率说明组织了多少通往外部网络的Web事务。提高文档命中率对降低整体延迟很有好处。字节命中率说明阻止了多少字节传向因特网。提高字节命中率对节省带宽很有利。


### 7.5.4 区分命中和未命中的情况

客户端有一种方法判断响应是否来自缓存，就是使用Date首部。将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存响应。客户端也可以通过Age首部来检测缓存的响应，通过这个首部可以分表这条相应的使用期。

## 7.6 缓存的拓扑结构

### 7.6.1 私有缓存

私有缓存不需要恨得的动力或存储空间，这样就可以将其做的很小，很便宜。Web浏览器中内建的私有缓存——大多数浏览器多会将常用的文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置。
 

### 7.6.2 公有代理缓存

公有缓存是特殊的共享代理服务器，被称为缓存代理服务器(caching proxy server)，代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。


### 7.6.3 代理缓存的层次结构

在实际中，事项层次化的缓存是很有意义的，在这种结构中，在较小缓存命中的请求会被导向较大的父缓存，由它来为剩下的那些“提炼过的”流量提供服务。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能功能更强的缓存来装载更多用户共享的文档。


在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，当代理链路变得很长的情况下，这种性能损耗会变得非常明显。

### 7.6.4 网状缓存、内容路由以及对等缓存

有些网络结构会构建复杂的网状缓存。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的通信决策，决定于哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和送达，因此可将其称为内容路由。

网状缓存中内容路由设计的缓存要完成下列所有功能。

* 根据URL在父缓存与原始服务器之间进行动态的选择。
* 根据URL动态的选择一个特定的父缓存。
* 前往父缓存之前，在本地缓存中搜索已缓存的副本。
* 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过他们的缓存。

缓存之间这些更为复杂的关系允许不同的组织互为对等实体，将它们的缓存连接起来实现共赢。提供可选的对等支持的缓存被称为兄弟缓存。HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP进行了扩展，比如因特网缓存协议(ICP)和超文本缓存协议（HTCP）。

## 7.7 缓存的处理步骤

![](https://i.imgur.com/Hvy1lI1.png)

### 第一步——接收

在第一部中，缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。

### 第二步——解析

接下来，缓存将请求报文解析为片段，将首部的哥哥部分放入易于操作的数据结构中。这样缓存软件更容易处理首部字段并修改它们了。

### 第三步——查找

第三步中，缓存读取了URL，查找本地副本。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取。或者返回一条错误信息。

已缓存对象包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象还包含了一些元数据，用来记录对象在缓存中停留了多长时间，以及他被用过多少次等。

### 第四步———新鲜度检测

HTTP通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档时“新鲜的”，缓存可以在不联系服务器的情况下直接提供该文档。但一旦已缓存副本停留的时间太长了，超过了文档的新鲜度限值，就认为对象过时了，在提供该文档之前，缓存要再次与服务器进行确认，以检查文档是否发生了变化。客户端发送给缓存的所有请求首部紫衫都可以强制进行再验证，或者温泉避免再验证，这使得事情变得更加复杂了。

HTTP有一组非常复杂的新鲜度检测规则，缓存产品支持的大量配置选项，以及与非HTTP新鲜度标准进行互通的需要则使问题变得更加严重了。

###  第五步——创建响应

我们希望缓存的响应看起来就像来自原始服务器的一样，缓存将一缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础手部进行了修改和扩充。

缓存负责对这些首部进行改造，以便与客户端的要求相匹配。注意，缓存不应该调整Date首部。


### 第六步——发送

一旦响应首部准备好了，缓存就响应会送给客户端。代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效的发送数据，通常避免在本地缓存和网络I/O缓冲区之间进行文档内容的复制。

### 第七部——日志

大多数缓存会保存日志文件以及与缓存的适用有关的一些统计数据。

## 7.8 保持副本的新鲜

可能不是所有的以缓存副本都与服务器的文档一致。已缓存数据数据要与服务器数据保持一致。

HTTP有一些简单的机制可以在不要求服务器记住有些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些简单的机制称为文档过期和服务器再验证。

### 7.8.1 文档过期

通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。这些首部说明了在多长时间内可以将这些内容视为新鲜的。

在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系。但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果修改过，就要获取一份新鲜的副本。

### 7.8.2 过期日期和使用期

服务器用HTTP/1.0+的Expires首部或HTTP1.1的Cache-Control：max-age响应首部来指定过期日期，同时还会带有响应主体。Expires首部和Cache-Control：max-age首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。绝对日期依赖于计算机时钟的正确设置。


### 7.8.3 服务器再验证

* 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在就稳当的位置上，然后将文档发送给客户端。
* 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对环村中的首部进行更新就行了。

HTTP协议要求行为正确的缓存返回下列内容之一：

* 足够新鲜的已缓存副本
* 与服务器进行再验证，确认其仍然新鲜的已缓存副本。
* 如果需要与之进行再验证的原始服务器出现了故障，就返回一条错误报文。
* 附有警告信息说明内容可能不正确的已缓存副本。

### 7.8.4 用条件方法进行再验证

HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才会送对象主体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件GET。

HTTP定义了5个条件请求首部。对缓存再验证来说最有用的2个首部是If-Modified-Since和If-None-Match。

## If-Modified-Since:Date再验证

If-Modified-Since再验证请求通常被称为IMS请求。只有自某个日期之后自愿发生了变化的时候，IMS请求才会只是服务器执行请求：

* 如果自指定日期后，文档修改了，If-Modified-Since条件就为真，通常GET就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。
* 如果自指定日期后，文档没给修改过，条件就为假，会向客户端返回一个小的304 Not Modified响应报文，为了提高有效性，不会返回文档的主体。这下首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如Content-Type首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。


If-Modified-Since首部可以与last-Modified服务器响应首部配合工作。原始服务器会将最后修改日期附加到所提供的文档上去。当缓存要对一缓存文档进行再验证时，就会包含一个If-Modified-Since首部，其中携带有最后修改已缓存副本的日期

	If-Modified-Since：<cached last-modified date>

如果在此期间内容修改了，最后的修改日期就会有所不同，原始服务器就会会送新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符，会返回一个304 Not Modified响应。


注意，有些Web服务器并没有将If-Modified-Since作为真正的日期来进行比对。相反，它们在IMS日期和最后修改日期之间信息经了字符串匹配。这样的得到语义就是“如果最后的修改不是在这个确定的日期进行的”，而不是“如果在这个日期之后没有被修改过”。将最后袖肥日期作为某种序列号使用时，这种题带雨衣能够很好地识别出缓存是否过期，但这会妨碍客户端将If-Modified-Since首部用于真正基于时间的一些目的。

### 7.8.6 If-None-Match：实体标签再验证

有些情况下仅适用最后修改日期进行再验证是不够的。

* 有些文档可能会被周期性地重写，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
* 有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据。
* 有些服务器无法准确的判定其页面的最后修改日期。
* 有些服务器提供的文档会在亚秒间隙发生变化，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。

为了解决这些问题，HTTP允许用户对被称为实体标签的“版本标识符”进行比较。实体标签是附加到文档上的任意标签。它们可能包含了文档的序列号或版本号 ，或者是文档内容的校验和及其他指纹信息。

当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样如果实体标签被修改了，缓存就可以用If-None-Match条件首部来GET文档的新副本了。

可以在If-None-Match首部包含几个实体标签，高速服务器，带有这些实体标签的对象副本在缓存上已经有了：

	If-None-Match："v2.6"
	IF-None-Match :"v2.4","v2.5","v2.6"
	IF-None-MAtch: "foobar","A34FAC0095","Profiles in Courage"

### 7.8.7 强弱验证器

缓存可以用实体标签来判断，与服务器相比，已缓存版本是不是新的。从这个角度来看，实体标签和最近修改日期都是缓存验证器。

有时服务器希望在对文档进行一些非实质性或不重要的修改时，不要使所有的已缓存副本都失效。HTTP/1.1支持“弱验证器”，如果支队内容进行了少量修改，就允许服务器声明那是“足够好”地等价体。

只要内容发生了变化，强验证器就会变化。弱验证器允许对一些内容进行修改，但内容的主要含义发生了变化时，通常它还是会变化的。有些操作不能用弱验证器来实现，所以，服务器会用前缀“W/”来标识弱验证器。

	ETag: W/"v2.6"
	If-None-Match: W/"v2.6"

注意，原始服务器一定不能为两个不同的实体重用一个特定的强实体标签值，或者为两个语义不同的实体重用一个特定的弱实体标签值。不管过期时间是多少，缓存条目都可能晖六村任意长的时间，因此，假设缓存不会再次通过它在过去某个时刻获得的验证器，对一个条目进行验证是不合适的。

### 7.8.8 什么时候应该使用实体标签和最近修改日期

如果服务器徽松了一个实体标签，HTTP/1.1客户端就必须使用实体标签验证器。如果服务器只会送了一个Last-Modified值，客户端就可以使用If-Modified-Since验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种在验证方案。

除非HTTP/1.1原始服务器无法生成实体标签验证器，否则就应该发送一个出去，如果使用弱实体标签有优势的话，发送的可能就是弱实体标签，。而且，最发哦同时发送一个最近修改值。

如果HTTP/1.1缓存或服务器收到的请求既带有If-Modified-Since，又带有实体标签条件首部，俺么只有这两个条件都满足时，才能返回304 Not Modified 响应。

## 7.9 控制缓存的能力

服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多少时间。按照优先级递减的顺序，服务器可以：

* 附加一个Cache-Control：no-store首部到响应中去；
* 附加一个Cache-Control：no-chche首部到响应中去；
* 附加一个Cache-Control：must-revalidate首部到响应中去；
* 附加一个Cache-Control：max-age首部到响应中去；
* 不附加过期信息，让缓存确定自己的过期日期。

### no-Store与no-Cache响应首部

标识为no-store的相应会禁止缓存对响应进行复制。缓存通常会像费缓存代理服务器一样，向客户端转发一条no-store响应，然后删除对象。

标识为no-cache的响应实际上是可以存储在本地缓存区中的。只是在于原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。









